\documentclass{CRPITStyle} 
\usepackage{harvard}  
\usepackage{graphicx}
\pagestyle{empty}
\thispagestyle{empty}
\hyphenation{roddick}
\bibliographystyle{agsm}   
\graphicspath{ {images/} }

\begin{document}

	\title {Software Development Life Cycles: History and Future}
	\author {Aden Kenny}
	\maketitle

	\begin {abstract} 
		This paper discusses the importance of the use of process models in the software development life cycle, provides a
		review of the process models used so far, compares and contrasts five different process models and then attempts to
		discuss the future of process models.
	\end {abstract}

	
	\section {Introduction} 
		\textit{The Software Crisis} was a time period in the infancy of software development where it was found to be difficult 
		to write software that was useful and efficient on the hardware of the time. This led to a large quantity of poor quality
		software being created that did not meet the requirements or was not even delivered at all.\\
		~\\
		It has been stated that there were problems of "achieving sufficient reliability" and difficulties of meeting time
		requirements and specifications on large scale projects amongst other problems that were discussed at the \textit{NATO
		Software Engineering Conference, 1968} (Naur and Randell, 1969).\\
		~\\
		As a result of this conference where major problems with the state of software development were brought up, software
		development process models started to become far more popular as they were seen as a major part of the solution to the
		\textit{Software Crisis}.

	\section {The importance of process models}
		During the \textit {Software Crisis} discussed above, many problems were faced possibly to the lack of direction in the
		development of software. These issues were things like projects being over budget, projects running over-time,
		inefficiency in the delivered software, projects that did not meet the set requirements, unmanageable projects, and
		projects that never delivered software. \\
		~\\
		 A solution that was proposed to the problems that software was facing was the idea
		of a development process guided by the usage of a framework. These frameworks later became known as 'process
		models'. \\
		~\\
		Nearly all software development process models start with a requirements gathering phase where the requirements that
		need to be met are gathered. This step is extremely important to the development of software as a program is highly
		unlikely to meet the requirements set by the client if the requirements have not been formally gathered and analysed.\\
		~\\
		A process model proves itself extremely useful in large scale, team projects. This is because a process model forms a 
		base on which a team can find a common understanding in the development of software. This is due to that idea that all
		software development projects have a process called the \textit{ software life cycle }. This involves a number of steps
		starting with "Requirements analysis and definition", "System design", "Program design", "Writing programs 
		(implementation)", "Testing", and "System delivery (deployment)" (Ma, 2017).\\
		~\\
		A set process model in a project means that a team will have a way of fulfilling the process of the software life cycle.
		This becomes important as it allows the team to have a common understanding what needs to be done at all times no
		matter what model is used. 

	\section {Review of proposed models}

		One of the first formally described process models was the the \textit{Waterfall model} by Winston Royce in 1970.
		Royce states that he believes in the concept of analysis before coding but presents the model as "risky" and that it
		"invites failure" (Royce, 1970).\\
		~\\
		The main idea to take away from Royce's paper is that analysis is a required step in the software development life cycle.
		This is very important as good software cannot be developed without fully understanding the problem that the software
		is designed to solve and all of the complexities involved, of which there will inevitably be many.\\
		~\\
		The waterfall model has been criticised as it is quite inflexible in some situations especially in the case of changing
		or unclear requirements. If a new requirement is requested or found to be needed it is not possible to go back a phase
		and insert this new requirement. The new requirement must either be ignored and not implemented, or the entire
		process must be restarted. Other problems include a long development time with nothing to show before the end and
		the idea that it "Views software development as [a] manufacturing process rather than a creative process" (Ma, 2017).\\
		~\\
		It was realised by some people quite soon after the adoption of the waterfall method that it was flawed in some 
		situations such as by Royce where he first formally describes it and criticises it (Royce, 1970). This led to the
		development of other process models that were designed to fix the shortcomings of the waterfall model. Examples of
		these models include \textit{Waterfall model with prototyping}. \\
		~\\
		 This is an arguably more flexible version of the waterfall model. It involves following the same
		 design cycle as the waterfall model but involves prototyping in the design phase
		and the ability to move back to the requirements and system design phases in the testing phase.\\
		~\\
		The idea of a more flexible process model than waterfall has been frequently seen as advantageous in many situations
		which has recently led to more 'lightweight methods' gaining popularity. These lightweight methods generally focus 
		more on flexibility and the opportunity to go back to previous cycles to fix mistakes and add features that were not
		in the initial requirements, either through changing customer requirements or incomplete requirements gathering.\\
		~\\
		The waterfall model has been described as a "heavyweight method" (Ma, 2017). These 'heavyweight methods' 
		do have advantages over so called 'lightweight models'. The waterfall model provides an extremely useful case
		to examine the advantages of heavyweight models as it is possibly the most frequently used heavyweight model
		and because of its long history and the large amount of use it has had. \\
		~\\
		One of the main cited advantages of the waterfall model is it is frequently possible that errors in design are found
		before any code is actually written (Hughey, 2009). This saves time during the implementation phase as 
		there will be no need, in an ideal situation, to go back to the planning stage of the life cycle. An additional frequently
		mentioned advantage is the idea that a very structured model means that it is far easier to measure the progress of the project
		when compared to more lightweight models, as the project milestones are clearly defined.\\
		~\\
		A major difference between the methodologies that it is frequently cited is the idea of iterative development. More 
		lightweight, agile, methods such as Scrum or Extreme Programming (XP) require that features are developed iteratively
		and favours short release cycles with frequent feedback from the customer. This is contrast to so called 'less flexible'
		models like waterfall. These more heavyweight models call for a single release at the end. Critics of waterfall state
		that this can be harmful to the project as it becomes extremely infeasible to get customer or stakeholder feedback
		on the current state of the project. 
		
		
	\section {Comparison of process models}
	
		This section will compare and contrast five different process models.\\
		~\\
		These models are as follows:
		
		\begin{itemize}
			\item Waterfall model
			\item Spiral model
			\item V model
			\item Extreme Programming (XP)
			\item Scrum
		\end{itemize}~\\
		
		In order to simplify discussion of these five models they will broken down into three different groups. First we have the so called `lightweight
		methods' which consists of XP and Scrum. Secondly we have the more `heavyweight methods' which consists of Waterfall and the V model. Finally
		we have the Spiral model which does not quite fit into either category. It has many similarities to the heavyweights such as a similar life cycle, but
		done multiple times, as required, and similarities to the lightweights such as multiple iterations (which is the life cycle done multiple times). It also
		has unique features which the heavyweights and the lightweights do not have such as a strong focus on risk management. We will place the
		Spiral into its own category of `intermediate methods'.\\
		~\\
		First to be discussed will be the Waterfall model. As previously mentioned in above sections the waterfall model has been criticised
		but still remains one of the most used process models.
		This is because while it has some disadvantages it also has a significant amount of advantages (Ma, 2017) along with a long history of usage.\\
		~\\
		It ``works for well understood problems with minimal or no changes in the requirements'' (Ma, 2017). This is due to the fact that
		it does not provide for iterative development so all work that is done works towards the set requirements, and if the requirements
		that are set at the start of the project remain constant it allows for potentially faster delivery when compared to a more lightweight
		model such as Scrum which calls for a more flexible approach based around the idea that a problem cannot be fully defined, so it focuses
		more on quick iterations based around changing requirements.\\
		~\\
		Waterfall, along with the V model that it is the parent of, are the only two models discussed here that do not provide for iterative
		development. XP and Scrum provide for it as they are Agile methodologies and Agile calls for iterative development.\\
		~\\
		 The other model that will be discussed is the Spiral model. The Spiral model was first introduced by Barry Boehm in 
		 1986 as a ``candidate for improving the software process model situation'' (Boehm, 1986). It is stated that it creates a ``risk-driven
		 approach to the software process' (Boehm, 1986).\\
		 ~\\
		The Spiral calls for multiple iterations like the lightweights but each of these iterations being so called `cycles', and each Waterfall
		activity becomes a cycle. The Spiral does differ from the lightweights as \includegraphics{spiral2}

\begin{thebibliography}{xx}

	\harvarditem{[Naur and Randell]}
  	{1969}{null}
	Naur, P. \harvardand\ Randell, B.  \harvardyearleft
  	1969\harvardyearright , "Software Engineering - Report on a conference sponsored by the NATO Science Committee".
	
	\harvarditem{[Royce]}
	{1970}{null}
	Royce, W. \harvardyearleft
	1970\harvardyearright, "Managing the Development of Large Software Systems" {\em in} Proceedings of IEEE WESCON.

	\harvarditem{[Ma]}
	{2017}{null}
	Ma, H. \harvardyearleft
	2017\harvardyearright, "Classical Software Life Cycle Models" {\em in} lecture notes distributed in SWEN301.
	
	\harvarditem{[Larman]}
	{2003}{null}
	Larman, C. \harvardand\ Basili, V. \harvardyearleft
	2003\harvardyearright, "Iterative and Incremental Development: A Brief History" {\em in} IEEE Computer (June ed.). 36:
	47-56.
	
	\harvarditem{[Hughey]}
	{2009}{null}
	Hughey, D. \harvardyearleft
	2009\harvardyearright, "Comparing Traditional Systems Analysis and Design with Agile Methodologies". University of
	Missouri - St. Louis.
	
	\harvarditem{[Boehm]}
	{1986}{null}
	Bohem, B. \harvardyearleft
	1986\harvardyearright, ``A Spiral Model of Software Development and Enhancement'' {\em in} ACM SIGSOFT Software Engineering
	Notes (Volume 11, Issue 4, August 1986). 14-24.

\end{thebibliography}
		

\end{document}